<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Fusion Layout Viewer</title>
    <link rel="icon" type="image/png"
        href="git/img/logo.svg" />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #101010;
            font-family: system-ui, sans-serif;
            color: white;
        }

        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            font-size: 13px;
            z-index: 10;
            max-width: 128px;
        }

        #info i {
            font-size: 11px;
            color: #aaa;
        }

        #layoutSelector {
            position: fixed;
            top: 10px;
            left: 10.5rem;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            font-size: 13px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #layoutSelector label {
            font-weight: bold;
            margin-bottom: 4px;
        }

        #layoutSelector select {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: white;
            font-size: 13px;
            cursor: pointer;
        }

        #layoutSelector select:hover {
            border-color: #666;
        }

        #layoutDescription {
            font-size: 11px;
            color: #aaa;
            margin-top: 4px;
            line-height: 1.4;
        }

        .atlasPreview {
            position: fixed;
            right: 10px;
            max-width: 256px;
            max-height: 256px;
            border: 1px solid #ffffff;
            image-rendering: pixelated;
            background: #000;
            z-index: 9;
        }

        #atlasPreviewVertical {
            top: 10px;
        }

        #atlasPreviewHorizontal {
            top: 290px;
            /* Default, will be updated dynamically */
        }

        .atlasLabel {
            position: fixed;
            right: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 6px;
            z-index: 9;
        }

        #labelVertical {
            top: 10px;
            transform: translateY(-18px);
        }

        #labelHorizontal {
            top: 290px;
            /* Default, will be updated dynamically */
            transform: translateY(-18px);
        }

        #autoReloadContainer {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            font-size: 13px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #autoReloadContainer input,
        #autoReloadContainer label {
            cursor: pointer;
        }

        #autoReloadContainer label {
            user-select: none;
        }

        #reloadStatus {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }

        #reloadStatus.active {
            color: #4f4;
        }

        .textureUpload {
            position: fixed;
            right: 275px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #uploadVertical {
            top: 10px;
        }

        #uploadHorizontal {
            top: 290px;
            /* Default, will be updated dynamically */
        }

        .uploadBtn {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .uploadBtn:hover {
            border-color: #666;
            background: #333;
        }

        .uploadBtn.loaded {
            border-color: #4a4;
            background: #243;
        }

        .fileName {
            font-size: 10px;
            color: #888;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .urlInput {
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: white;
            font-size: 10px;
            width: 120px;
        }

        .urlInput:focus {
            outline: none;
            border-color: #666;
        }

        .urlInput::placeholder {
            color: #666;
        }

        .loadUrlBtn {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #333;
            color: white;
            font-size: 10px;
            cursor: pointer;
            aspect-ratio: 1/1;
            height: full;
        }

        .loadUrlBtn:hover {
            border-color: #666;
            background: #444;
        }

        .urlRow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 0;
        }

        #texturePresets {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            font-size: 13px;
            z-index: 10;
            display: flex;
            gap: 8px;
        }

        .presetBtn {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .presetBtn:hover {
            border-color: #666;
            background: #333;
        }

        .presetBtn.active {
            border-color: #4a4;
            background: #243;
        }
    </style>

    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>

<body>

    <div id="info">
        <img src="git/img/logo.svg" alt="Fusion Logo"
            style="height: 32px;" />
        <br />Fusion Layout Viewer<br />
        <i>Not affiliated with SuperMartijn642</i><br />
        <a href="https://github.com/SuperMartijn642/Fusion/wiki/Texture-Types" target="_blank"
            style="color: #8af;">Documentation</a>
    </div>

    <div id="layoutSelector">
        <label for="layoutSelect">Layout Type:</label>
        <select id="layoutSelect">
            <option value="full">Full (8x8)</option>
            <option value="simple">Simple (4x4)</option>
            <option value="compact">Compact (5x1)</option>
            <option value="horizontal">Horizontal (4x1)</option>
            <option value="vertical">Vertical (1x4)</option>
        </select>
        <div id="layoutDescription">64 tiles for all neighbor combinations</div>
    </div>

    <div id="autoReloadContainer">
        <input type="checkbox" id="autoReload" />
        <label for="autoReload">Auto-reload textures</label>
        <span id="reloadStatus"></span>
    </div>

    <div id="labelVertical" class="atlasLabel">Vertical (sides)</div>
    <canvas id="atlasPreviewVertical" class="atlasPreview"></canvas>

    <div id="uploadVertical" class="textureUpload">
        <button class="uploadBtn" id="uploadVerticalBtn">
            Load Vertical
        </button>
        <input type="file" id="fileVertical" accept="image/png" style="display: none" />
        <span id="fileNameVertical" class="fileName"></span>
        <div class="urlRow">
            <input type="text" id="urlVertical" class="urlInput" placeholder="URL..." />
            <button class="loadUrlBtn" id="loadUrlVerticalBtn">→</button>
        </div>
    </div>

    <div id="labelHorizontal" class="atlasLabel">Horizontal (top/bottom)</div>
    <canvas id="atlasPreviewHorizontal" class="atlasPreview"></canvas>

    <div id="uploadHorizontal" class="textureUpload">
        <button class="uploadBtn" id="uploadHorizontalBtn">
            Load Horizontal
        </button>
        <input type="file" id="fileHorizontal" accept="image/png" style="display: none" />
        <span id="fileNameHorizontal" class="fileName"></span>
        <div class="urlRow">
            <input type="text" id="urlHorizontal" class="urlInput" placeholder="URL..." />
            <button class="loadUrlBtn" id="loadUrlHorizontalBtn">→</button>
        </div>
    </div>

    <div id="texturePresets">
        <button class="presetBtn" id="presetCurrent">Current</button>
        <button class="presetBtn" id="presetNumbered">Numbered</button>
        <button class="presetBtn" id="presetExample">Example</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';


        /**
         * ============================================================================
         * CONSTANTS
         * ============================================================================
         */

        // Face indices for Three.js BoxGeometry
        const FACE = {
            POS_X: 0,  // +X (right)
            NEG_X: 1,  // -X (left)
            POS_Y: 2,  // +Y (top) - horizontal face
            NEG_Y: 3,  // -Y (bottom) - horizontal face
            POS_Z: 4,  // +Z (front)
            NEG_Z: 5   // -Z (back)
        };

        // Shared CSV pattern for full and simple layouts (same demo, different tile selection)
        const DEMO_CSV_FULL = `
1,,10,12,,2,3,4,,9,,5,4,,2,6,,,9,,9,,,2,8,4,,,9,,,,9,,10,12,,10,11,12,,5,3,6,,10,11,12,,10,12,,9,,,,9,,10,24,4,,,10,12,,10,11,12,,,9,,,,10,12,,10,12,,,,9,,,10,11,12,,10,12,,,,10,12,,10,11,12,,10,12,,,,10,12,,10,12,,,,9,,,,9,,,,10,12,,9,,2,4
,,26,28,,,,,,17,,25,,,,25,,2,14,,13,4,,,25,,,2,15,4,,10,30,,21,28,,26,27,28,,17,,17,,18,19,20,,18,20,,7,4,,2,16,,26,28,,,2,31,28,,26,43,28,,10,36,12,,2,35,20,,19,44,4,,2,34,4,,26,40,20,,18,47,12,,10,48,20,,18,39,28,,26,41,12,,10,33,28,,26,46,4,,2,37,12,,10,38,4,,2,45,28,,25,,,
,,,,,,,,,25,,,,,,,,,,,,,,,,,,,,,,26,28,,25,,,,,,,13,3,14,,26,27,28,,26,28,,25,,,,25,,,,,,,,,,,25,,,26,27,28,,,26,28,,26,28,,,,25,,,,26,28,,26,27,28,,26,27,28,,26,28,,,,26,28,,26,28,,,,25,,,,26,28,,26,28,,,,25
`.trim();

        // DOM element cache (initialized after DOMContentLoaded is implicit in module scripts)
        const DOM = {
            // Layout UI
            layoutSelect: document.getElementById('layoutSelect'),
            layoutDescription: document.getElementById('layoutDescription'),
            
            // Atlas previews
            atlasPreviewVertical: document.getElementById('atlasPreviewVertical'),
            atlasPreviewHorizontal: document.getElementById('atlasPreviewHorizontal'),
            
            // Labels
            labelVertical: document.getElementById('labelVertical'),
            labelHorizontal: document.getElementById('labelHorizontal'),
            
            // Upload containers
            uploadVertical: document.getElementById('uploadVertical'),
            uploadHorizontal: document.getElementById('uploadHorizontal'),
            uploadVerticalBtn: document.getElementById('uploadVerticalBtn'),
            uploadHorizontalBtn: document.getElementById('uploadHorizontalBtn'),
            
            // File inputs
            fileVertical: document.getElementById('fileVertical'),
            fileHorizontal: document.getElementById('fileHorizontal'),
            fileNameVertical: document.getElementById('fileNameVertical'),
            fileNameHorizontal: document.getElementById('fileNameHorizontal'),
            
            // URL inputs
            urlVertical: document.getElementById('urlVertical'),
            urlHorizontal: document.getElementById('urlHorizontal'),
            loadUrlVerticalBtn: document.getElementById('loadUrlVerticalBtn'),
            loadUrlHorizontalBtn: document.getElementById('loadUrlHorizontalBtn'),
            
            // Auto-reload
            autoReload: document.getElementById('autoReload'),
            reloadStatus: document.getElementById('reloadStatus'),
            
            // Preset buttons
            presetCurrent: document.getElementById('presetCurrent'),
            presetNumbered: document.getElementById('presetNumbered'),
            presetExample: document.getElementById('presetExample')
        };


        /**
         * ============================================================================
         * GLOSSARY / KEY TERMS
         * ============================================================================
         * 
         * Atlas:
         *   A single image containing multiple smaller images (tiles) arranged in a grid.
         *   Instead of loading 64 separate textures, we pack them all into one image.
         *   This is more efficient for the GPU and reduces HTTP requests.
         * 
         * Tile:
         *   One individual texture within the atlas.
         *   Each tile represents a specific neighbor configuration (edges, corners, etc.).
         * 
         * UV Coordinates:
         *   A 2D coordinate system (U = horizontal, V = vertical) used to map a texture onto 3D geometry.
         *   Values range from 0 to 1. UV (0,0) is typically bottom-left, (1,1) is top-right.
         * 
         * Neighbor:
         *   An adjacent cube in 3D space. Each face checks its neighbors to pick the right tile.
         * 
         * Layout Types:
         *   - Full (8x8):       64 tiles, handles all neighbor combinations including diagonals
         *   - Simple (4x4):     16 tiles, handles direct neighbors only (no diagonals)
         *   - Compact (5x1):    5 tiles, for reduced patterns with borders
         *   - Horizontal (4x1): 4 tiles, single row of cubes
         *   - Vertical (1x4):   4 tiles, single column of cubes
         * 
         */


        /**
         * ============================================================================
         * LAYOUT DEFINITIONS
         * Each layout defines its texture dimensions, tile mapping, and demo patterns
         * ============================================================================
         */

        const layouts = {
            full: {
                name: 'Full',
                description: '48 tiles (8x6) or 64 tiles (8x8) for all neighbor combinations',
                columns: 8,
                rows: 6,  // Default, will be auto-detected from image (6 or 8)
                autoDetectRows: true,  // Enable dynamic row detection
                horizontalTexture: 'textures/full_horizontal.png',
                verticalTexture: 'textures/full_vertical.png',
                patternsPerRow: 8,
                spacingX: 24,
                spacingZ: 24,
                // CSV patterns to demonstrate all tile types
                csv: DEMO_CSV_FULL,
                findTilePosition: findFullTilePosition
            },

            simple: {
                name: 'Simple',
                description: '16 tiles for direct neighbors only (no diagonals)',
                columns: 4,
                rows: 4,
                horizontalTexture: 'textures/simple_horizontal.png',
                verticalTexture: 'textures/simple_vertical.png',
                patternsPerRow: 8,
                spacingX: 24,
                spacingZ: 24,
                // Same patterns as full, but simpler tile selection
                csv: DEMO_CSV_FULL,  // Reuse full layout CSV
                findTilePosition: findSimpleTilePosition
            },

            compact: {
                name: 'Compact',
                description: '5 tiles for reduced patterns with borders',
                columns: 5,
                rows: 1,
                horizontalTexture: 'textures/compact_horizontal.png',
                verticalTexture: 'textures/compact_vertical.png',
                patternsPerRow: 6,
                spacingX: 20,
                spacingZ: 20,
                csv: `
1,,1,1,1,,1,,1,1,1,,,1
,,1,1,1,,1,,,,,,1,1,1
,,1,1,1,,1,,,,,,,1
`.trim(),
                findTilePosition: findCompactTilePosition
            },

            horizontal: {
                name: 'Horizontal',
                description: '4 tiles for single horizontal row',
                columns: 4,
                rows: 1,
                singleTexture: true,  // Only one texture for all faces
                horizontalTexture: 'textures/horizontal.png',
                verticalTexture: 'textures/horizontal.png',
                patternsPerRow: 2,
                spacingX: 8,
                spacingZ: 8,
                csv: `1,,1,2,,1,2,3`.trim(),
                findTilePosition: findHorizontalTilePosition
            },

            vertical: {
                name: 'Vertical',
                description: '4 tiles for single vertical column',
                columns: 1,
                rows: 4,
                singleTexture: true,  // Only one texture for all faces
                horizontalTexture: 'textures/vertical.png',
                verticalTexture: 'textures/vertical.png',
                patternsPerRow: 4,
                spacingX: 8,
                spacingZ: 8,
                csv: `
1,,1,,1,,1
,,2,,2,,2
,,,,3,,3
,,,,,,4
`.trim(),
                findTilePosition: findVerticalTilePosition
            }
        };


        /**
         * ============================================================================
         * TILE POSITION FUNCTIONS
         * Each layout has its own algorithm to map neighbors to tile coordinates
         * ============================================================================
         */

        /**
         * Full layout (8x8): All 64 combinations with diagonal awareness
         * @see https://github.com/SuperMartijn642/Fusion/blob/forge-1.20/src/main/java/com/supermartijn642/fusion/texture/types/connecting/layouts/FullLayoutHandler.java
         */
        function findFullTilePosition(neighbors) {
            const { top, topRight, right, bottomRight, bottom, bottomLeft, left, topLeft } = neighbors;

            // Case 1: Isolated cube (no direct neighbors)
            if (!left && !top && !right && !bottom) {
                return [0, 0];
            }

            // Case 2: Single direct neighbor
            if (left && !top && !right && !bottom) return [3, 0];
            if (!left && top && !right && !bottom) return [0, 3];
            if (!left && !top && right && !bottom) return [1, 0];
            if (!left && !top && !right && bottom) return [0, 1];

            // Case 3: Two opposite neighbors (straight line)
            if (left && !top && right && !bottom) return [2, 0];
            if (!left && top && !right && bottom) return [0, 2];

            // Case 4: Two adjacent neighbors (corner)
            if (left && top && !right && !bottom) {
                return topLeft ? [3, 3] : [5, 1];
            }
            if (!left && top && right && !bottom) {
                return topRight ? [1, 3] : [4, 1];
            }
            if (!left && !top && right && bottom) {
                return bottomRight ? [1, 1] : [4, 0];
            }
            if (left && !top && !right && bottom) {
                return bottomLeft ? [3, 1] : [5, 0];
            }

            // Case 5: Three neighbors (edge of a surface)
            if (!left) {
                if (topRight && bottomRight) return [1, 2];
                if (topRight) return [4, 2];
                if (bottomRight) return [6, 2];
                return [6, 0];
            }
            if (!top) {
                if (bottomLeft && bottomRight) return [2, 1];
                if (bottomLeft) return [7, 2];
                if (bottomRight) return [5, 2];
                return [7, 0];
            }
            if (!right) {
                if (topLeft && bottomLeft) return [3, 2];
                if (topLeft) return [7, 3];
                if (bottomLeft) return [5, 3];
                return [7, 1];
            }
            if (!bottom) {
                if (topLeft && topRight) return [2, 3];
                if (topLeft) return [4, 3];
                if (topRight) return [6, 3];
                return [6, 1];
            }

            // Case 6: Four direct neighbors (middle of a surface)
            if (topLeft && topRight && bottomLeft && bottomRight) {
                return [2, 2];
            }

            // Single missing corner
            if (!topLeft && topRight && bottomLeft && bottomRight) return [7, 5];
            if (topLeft && !topRight && bottomLeft && bottomRight) return [6, 5];
            if (topLeft && topRight && !bottomLeft && bottomRight) return [7, 4];
            if (topLeft && topRight && bottomLeft && !bottomRight) return [6, 4];

            // Two opposite corners missing
            if (!topLeft && topRight && !bottomRight && bottomLeft) return [0, 4];
            if (topLeft && !topRight && bottomRight && !bottomLeft) return [0, 5];

            // Two adjacent corners missing
            if (!topLeft && !topRight && bottomRight && bottomLeft) return [3, 4];
            if (topLeft && !topRight && !bottomRight && bottomLeft) return [3, 5];
            if (topLeft && topRight && !bottomRight && !bottomLeft) return [2, 5];
            if (!topLeft && topRight && bottomRight && !bottomLeft) return [2, 4];

            // Single corner present
            if (topLeft) return [5, 5];
            if (topRight) return [4, 5];
            if (bottomRight) return [4, 4];
            if (bottomLeft) return [5, 4];

            // No corners
            return [1, 4];
        }

        /**
         * Simple layout (4x4): Only direct neighbors, no diagonals
         * @see https://github.com/SuperMartijn642/Fusion/blob/forge-1.20/src/main/java/com/supermartijn642/fusion/texture/types/connecting/layouts/SimpleLayoutHandler.java
         */
        function findSimpleTilePosition(neighbors) {
            const { top, right, bottom, left } = neighbors;

            // Fusion algorithm: Match exact logic from SimpleLayoutHandler.java
            // connectionsIndex = (top?1:0) | (right?2:0) | (bottom?4:0) | (left?8:0)

            // Count sides connected
            const sides = (top ? 1 : 0) + (right ? 1 : 0) + (bottom ? 1 : 0) + (left ? 1 : 0);

            // 0 sides - isolated
            if (sides === 0) {
                return [0, 0];
            }

            // 1 side only
            if (sides === 1) {
                if (left) return [3, 0];
                if (top) return [3, 1];
                if (right) return [2, 1];
                if (bottom) return [2, 0];
            }

            // 2 sides
            if (sides === 2) {
                // Straight lines
                if (left && right && !top && !bottom) return [0, 1];  // horizontal
                if (top && bottom && !left && !right) return [1, 1];  // vertical

                // Corners
                if (left && top) return [3, 3];  // top-left
                if (top && right) return [2, 3];  // top-right
                if (right && bottom) return [2, 2]; // bottom-right
                if (bottom && left) return [3, 2];  // bottom-left
            }

            // 3 sides (T-junctions)
            if (sides === 3) {
                if (!left) return [0, 2];  // T facing left (no left)
                if (!top) return [1, 2];  // T facing up (no top)
                if (!right) return [1, 3];  // T facing right (no right)
                if (!bottom) return [0, 3];  // T facing down (no bottom)
            }

            // 4 sides - all connected
            return [1, 0];
        }

        /**
         * Compact layout (5x1): Reduced patterns with borders
         * @see https://github.com/SuperMartijn642/Fusion/blob/forge-1.20/src/main/java/com/supermartijn642/fusion/texture/types/connecting/layouts/CompactLayoutHandler.java
         */
        function findCompactTilePosition(neighbors) {
            const { top, right, bottom, left, topLeft, topRight, bottomLeft, bottomRight } = neighbors;

            const sides = (top ? 1 : 0) + (right ? 1 : 0) + (bottom ? 1 : 0) + (left ? 1 : 0);

            // 0 or 1 sides connected
            if (sides === 0 || sides === 1) {
                return [0, 0];
            }

            // 2 sides
            if (sides === 2) {
                if (left && right) return [3, 0];      // Horizontal straight
                if (top && bottom) return [2, 0];      // Vertical straight
                return [0, 0];                          // Corner
            }

            // 3 sides
            if (sides === 3) {
                if (left && right) {
                    // Has horizontal + one vertical
                    if ((topLeft && top && topRight) || (bottomLeft && bottom && bottomRight)) {
                        return [3, 0];  // Full horizontal with corner
                    }
                    return [0, 0];
                }
                if (top && bottom) {
                    // Has vertical + one horizontal
                    if ((topLeft && left && bottomLeft) || (topRight && right && bottomRight)) {
                        return [2, 0];  // Full vertical with corner
                    }
                    return [0, 0];
                }
                return [0, 0];
            }

            // 4 sides
            if (topLeft && topRight && bottomLeft && bottomRight) {
                return [1, 0];  // All 4 sides + all corners
            }
            if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                return [4, 0];  // All 4 sides, no corners
            }
            return [0, 0];      // Mixed corners
        }

        /**
         * Horizontal layout (4x1): Left/right connections only
         * @see https://github.com/SuperMartijn642/Fusion/blob/forge-1.20/src/main/java/com/supermartijn642/fusion/texture/types/connecting/layouts/HorizontalLayoutHandler.java
         */
        function findHorizontalTilePosition(neighbors) {
            const { left, right } = neighbors;

            if (left && right) return [2, 0];  // Both sides connected
            if (left && !right) return [3, 0];  // Only left connected (right end)
            if (!left && right) return [1, 0];  // Only right connected (left end)
            return [0, 0];                        // Isolated (none)
        }

        /**
         * Vertical layout (1x4): Top/bottom connections only
         * @see https://github.com/SuperMartijn642/Fusion/blob/forge-1.20/src/main/java/com/supermartijn642/fusion/texture/types/connecting/layouts/VerticalLayoutHandler.java
         */
        function findVerticalTilePosition(neighbors) {
            const { top, bottom } = neighbors;

            if (top && bottom) return [0, 2];  // Both sides connected
            if (top && !bottom) return [0, 3];  // Only top connected (bottom end)
            if (!top && bottom) return [0, 1];  // Only bottom connected (top end)
            return [0, 0];                        // Isolated (none)
        }


        /**
         * ============================================================================
         * CONFIGURATION (dynamic, changes with layout)
         * ============================================================================
         */

        let currentLayout = 'full';
        let detectedRows = null;  // Rows detected from loaded texture (for layouts with autoDetectRows)
        
        // Track currently loaded texture URLs (for auto-reload)
        let currentVerticalUrl = null;
        let currentHorizontalUrl = null;

        const config = {
            get columns() { return layouts[currentLayout].columns; },
            get rows() {
                // Use detected rows if available and layout supports it
                if (detectedRows !== null && layouts[currentLayout].autoDetectRows) {
                    return detectedRows;
                }
                return layouts[currentLayout].rows;
            },
            get horizontalTexture() { return layouts[currentLayout].horizontalTexture; },
            get verticalTexture() { return layouts[currentLayout].verticalTexture; },
            get patternsPerRow() { return layouts[currentLayout].patternsPerRow; },
            get spacingX() { return layouts[currentLayout].spacingX; },
            get spacingZ() { return layouts[currentLayout].spacingZ; },
            get csv() { return layouts[currentLayout].csv; },
            get findTilePosition() { return layouts[currentLayout].findTilePosition; },

            // Fixed values
            cubeSize: 4,
            upscaleFactor: 8,
            reloadInterval: 1000
        };


        /**
         * ============================================================================
         * 3D SCENE INITIALIZATION
         * ============================================================================
         */

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 30, 55);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.NoToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(50, 0, 20);
        controls.update();


        /**
         * ============================================================================
         * TEXTURE MANAGEMENT
         * ============================================================================
         */

        const loader = new THREE.TextureLoader();
        let horizontalTexture = null;
        let verticalTexture = null;

        /**
         * Creates an upscaled texture for crisp pixel-art rendering.
         * Also detects the actual number of rows for layouts with autoDetectRows.
         */
        function createUpscaledTexture(originalTexture, previewCanvasId) {
            const image = originalTexture.image;
            const width = image.width;
            const height = image.height;

            // Auto-detect rows based on image aspect ratio for layouts that support it
            if (layouts[currentLayout].autoDetectRows) {
                const columns = layouts[currentLayout].columns;
                const tileWidth = width / columns;
                const calculatedRows = Math.round(height / tileWidth);

                // For full layout: support 8×6 (ratio 4:3) or 8×8 (ratio 1:1)
                if (currentLayout === 'full') {
                    detectedRows = (calculatedRows >= 7) ? 8 : 6;
                    console.log(`Full layout: detected ${detectedRows} rows from ${width}×${height} image`);
                } else {
                    detectedRows = calculatedRows;
                }
            }

            const canvas = document.createElement('canvas');
            canvas.width = width * config.upscaleFactor;
            canvas.height = height * config.upscaleFactor;

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Vertical flip for Three.js UV coordinates
            ctx.save();
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
            ctx.drawImage(image, 0, 0, width, height, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            if (previewCanvasId) {
                drawAtlasPreview(image, previewCanvasId);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.flipY = false;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.needsUpdate = true;

            return texture;
        }

        /**
         * Draws the atlas preview with grid overlay.
         * Handles non-square textures (e.g., compact 5×1, vertical 1×4)
         */
        function drawAtlasPreview(image, canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            // Calculate preview size to fit within 256px while keeping aspect ratio
            const maxPreviewSize = 256;
            const aspectRatio = image.width / image.height;

            let previewWidth, previewHeight;
            if (aspectRatio >= 1) {
                // Wider than tall (horizontal layouts like compact)
                previewWidth = maxPreviewSize;
                previewHeight = Math.max(32, maxPreviewSize / aspectRatio);
            } else {
                // Taller than wide (vertical layouts)
                previewHeight = maxPreviewSize;
                previewWidth = Math.max(32, maxPreviewSize * aspectRatio);
            }

            canvas.width = previewWidth;
            canvas.height = previewHeight;
            canvas.style.width = previewWidth + 'px';
            canvas.style.height = previewHeight + 'px';

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, previewWidth, previewHeight);

            const width = previewWidth;
            const height = previewHeight;

            // Green grid
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 1;

            for (let col = 0; col <= config.columns; col++) {
                const x = (col * width) / config.columns + 0.5;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let row = 0; row <= config.rows; row++) {
                const y = (row * height) / config.rows + 0.5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Red dots at corners
            ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
            for (let row = 0; row <= config.rows; row++) {
                for (let col = 0; col <= config.columns; col++) {
                    const x = (col * width) / config.columns;
                    const y = (row * height) / config.rows;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Update positions of horizontal elements based on vertical canvas height
            updatePreviewPositions();
        }

        /**
         * Repositions horizontal preview elements based on vertical canvas size.
         * Called after drawing atlas preview to handle non-square textures.
         */
        function updatePreviewPositions() {
            const verticalHeight = DOM.atlasPreviewVertical.offsetHeight || 256;
            const horizontalTop = 10 + verticalHeight + 20; // 10px margin + canvas + 20px gap

            DOM.atlasPreviewHorizontal.style.top = horizontalTop + 'px';
            DOM.labelHorizontal.style.top = horizontalTop + 'px';
            DOM.labelHorizontal.style.transform = 'translateY(-18px)';
            DOM.uploadHorizontal.style.top = horizontalTop + 'px';
        }

        /**
         * Loads textures for the current layout.
         */
        function loadTextures(callback) {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            let loaded = 0;
            const targetLoads = isSingleTexture ? 1 : 2;

            const onLoad = () => {
                loaded++;
                if (loaded === targetLoads && callback) {
                    callback();
                }
            };

            if (isSingleTexture) {
                // Single texture mode: load once and use for both
                loader.load(config.horizontalTexture, (tex) => {
                    horizontalTexture = createUpscaledTexture(tex, 'atlasPreviewVertical');
                    verticalTexture = horizontalTexture;  // Same texture for both
                    onLoad();
                }, undefined, (err) => {
                    console.warn(`Failed to load ${config.horizontalTexture}:`, err);
                    onLoad();
                });
            } else {
                // Dual texture mode: load both separately
                loader.load(config.horizontalTexture, (tex) => {
                    horizontalTexture = createUpscaledTexture(tex, 'atlasPreviewHorizontal');
                    onLoad();
                }, undefined, (err) => {
                    console.warn(`Failed to load ${config.horizontalTexture}:`, err);
                    onLoad();
                });

                loader.load(config.verticalTexture, (tex) => {
                    verticalTexture = createUpscaledTexture(tex, 'atlasPreviewVertical');
                    onLoad();
                }, undefined, (err) => {
                    console.warn(`Failed to load ${config.verticalTexture}:`, err);
                    onLoad();
                });
            }
        }


        /**
         * ============================================================================
         * MATERIAL SYSTEM
         * ============================================================================
         */

        let materialCache = new Map();

        /**
         * Calculates UV coordinates for a given tile index.
         * @param {number} tileIndex - 1-based tile index
         * @returns {Object} UV configuration { repeatX, repeatY, offsetX, offsetY }
         */
        function calculateTileUVs(tileIndex) {
            const index = tileIndex - 1;
            const column = index % config.columns;
            const rowFromTop = Math.floor(index / config.columns);
            const rowFromBottom = config.rows - 1 - rowFromTop;

            return {
                repeatX: 1 / config.columns,
                repeatY: 1 / config.rows,
                offsetX: column / config.columns,
                offsetY: rowFromBottom / config.rows
            };
        }

        /**
         * Configures a texture with the given UV parameters.
         * @param {THREE.Texture} texture - Source texture to clone and configure
         * @param {Object} uv - UV configuration from calculateTileUVs
         * @returns {THREE.Texture} Configured texture clone
         */
        function configureTexture(texture, uv) {
            const tex = texture.clone();
            tex.repeat.set(uv.repeatX, uv.repeatY);
            tex.offset.set(uv.offsetX, uv.offsetY);
            tex.needsUpdate = true;
            return tex;
        }

        /**
         * Updates all cached materials with new textures.
         * @param {string} type - 'horizontal', 'vertical', or 'both'
         */
        function updateCachedMaterials(type) {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            const updateHorizontal = isSingleTexture || type === 'horizontal' || type === 'both';
            const updateVertical = isSingleTexture || type === 'vertical' || type === 'both';

            materialCache.forEach((mats, tileIndex) => {
                const uv = calculateTileUVs(tileIndex);

                if (updateHorizontal) {
                    const newTex = configureTexture(horizontalTexture, uv);
                    if (mats.horizontal.map) mats.horizontal.map.dispose();
                    mats.horizontal.map = newTex;
                    mats.horizontal.needsUpdate = true;
                }
                if (updateVertical) {
                    const newTex = configureTexture(verticalTexture, uv);
                    if (mats.vertical.map) mats.vertical.map.dispose();
                    mats.vertical.map = newTex;
                    mats.vertical.needsUpdate = true;
                }
            });
        }

        /**
         * Gets or creates materials for a given tile.
         */
        function getMaterialsForTile(tileIndex) {
            if (materialCache.has(tileIndex)) {
                return materialCache.get(tileIndex);
            }

            const uv = calculateTileUVs(tileIndex);

            const materials = {
                horizontal: new THREE.MeshBasicMaterial({ map: configureTexture(horizontalTexture, uv) }),
                vertical: new THREE.MeshBasicMaterial({ map: configureTexture(verticalTexture, uv) })
            };

            materialCache.set(tileIndex, materials);
            return materials;
        }

        /**
         * Clears the material cache (needed when switching layouts).
         */
        function clearMaterialCache() {
            materialCache.forEach((mats) => {
                if (mats.horizontal.map) mats.horizontal.map.dispose();
                if (mats.vertical.map) mats.vertical.map.dispose();
                mats.horizontal.dispose();
                mats.vertical.dispose();
            });
            materialCache.clear();
        }


        /**
         * ============================================================================
         * FUSION TILE SELECTION
         * ============================================================================
         */

        const faceOrientations = [
            { up: [0, 1, 0], right: [0, 0, -1] },   // FACE.POS_X (+X, right)
            { up: [0, 1, 0], right: [0, 0, 1] },    // FACE.NEG_X (-X, left)
            { up: [0, 0, -1], right: [1, 0, 0] },   // FACE.POS_Y (+Y, top) - horizontal
            { up: [0, 0, 1], right: [1, 0, 0] },    // FACE.NEG_Y (-Y, bottom) - horizontal
            { up: [0, 1, 0], right: [1, 0, 0] },    // FACE.POS_Z (+Z, front)
            { up: [0, 1, 0], right: [-1, 0, 0] }    // FACE.NEG_Z (-Z, back)
        ];

        function positionToIndex(position) {
            const [col, row] = position;
            return col + row * config.columns + 1;
        }

        function analyzeNeighbors(cubeMap, cube, faceIndex) {
            const { up, right } = faceOrientations[faceIndex];

            const hasNeighbor = (dx, dy, dz) => {
                return cubeMap.has(`${cube.x + dx},${cube.y + dy},${cube.z + dz}`);
            };

            return {
                top: hasNeighbor(up[0], up[1], up[2]),
                topRight: hasNeighbor(up[0] + right[0], up[1] + right[1], up[2] + right[2]),
                right: hasNeighbor(right[0], right[1], right[2]),
                bottomRight: hasNeighbor(-up[0] + right[0], -up[1] + right[1], -up[2] + right[2]),
                bottom: hasNeighbor(-up[0], -up[1], -up[2]),
                bottomLeft: hasNeighbor(-up[0] - right[0], -up[1] - right[1], -up[2] - right[2]),
                left: hasNeighbor(-right[0], -right[1], -right[2]),
                topLeft: hasNeighbor(up[0] - right[0], up[1] - right[1], up[2] - right[2])
            };
        }


        /**
         * ============================================================================
         * MESH CREATION
         * ============================================================================
         */

        let cubeGeometry = new THREE.BoxGeometry(config.cubeSize, config.cubeSize, config.cubeSize);

        function createCubeMesh(cubeMap, cube) {
            const materials = [];

            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                const neighbors = analyzeNeighbors(cubeMap, cube, faceIndex);
                const tilePosition = config.findTilePosition(neighbors);
                const tileIndex = positionToIndex(tilePosition);
                const mats = getMaterialsForTile(tileIndex);

                // Use FACE constants for clarity: POS_Y (top) and NEG_Y (bottom) are horizontal faces
                const isHorizontalFace = (faceIndex === FACE.POS_Y || faceIndex === FACE.NEG_Y);
                materials[faceIndex] = isHorizontalFace ? mats.horizontal : mats.vertical;
            }

            return new THREE.Mesh(cubeGeometry, materials);
        }


        /**
         * ============================================================================
         * CSV PARSING AND PATTERN BUILDING
         * ============================================================================
         */

        function parsePatterns(csv, mode) {
            const lines = csv.split('\n').map(line => line.split(','));
            const numRows = lines.length;
            const numCols = Math.max(...lines.map(l => l.length));

            const columnHasValue = (col) => {
                return lines.some(line => line[col]?.trim());
            };

            const patterns = [];
            let col = 0;

            while (col < numCols) {
                while (col < numCols && !columnHasValue(col)) col++;
                if (col >= numCols) break;

                const patternStart = col;
                while (col < numCols && columnHasValue(col)) col++;

                const cubes = [];
                for (let c = patternStart; c < col; c++) {
                    for (let r = 0; r < numRows; r++) {
                        const value = parseInt(lines[r][c]?.trim(), 10);
                        if (isNaN(value)) continue;

                        const localX = c - patternStart;

                        if (mode === 'vertical') {
                            cubes.push({ x: localX, y: numRows - 1 - r, z: 0, value });
                        } else {
                            cubes.push({ x: localX, y: 0, z: r, value });
                        }
                    }
                }

                patterns.push({ cubes });
            }

            return patterns;
        }

        function buildCubeMap(cubes) {
            const map = new Map();
            cubes.forEach(c => map.set(`${c.x},${c.y},${c.z}`, true));
            return map;
        }

        // Keep track of pattern groups to remove them when switching layouts
        let patternGroups = [];

        function createPatternGroup(pattern, gridIndex, zOffset) {
            const group = new THREE.Group();

            const gridX = gridIndex % config.patternsPerRow;
            const gridZ = Math.floor(gridIndex / config.patternsPerRow) + zOffset;
            const baseX = gridX * config.spacingX;
            const baseZ = gridZ * config.spacingZ;

            const cubeMap = buildCubeMap(pattern.cubes);

            pattern.cubes.forEach(cube => {
                const mesh = createCubeMesh(cubeMap, cube);
                mesh.position.set(
                    baseX + cube.x * config.cubeSize,
                    cube.y * config.cubeSize,
                    baseZ + cube.z * config.cubeSize
                );
                group.add(mesh);
            });

            scene.add(group);
            patternGroups.push(group);
        }

        function clearPatterns() {
            patternGroups.forEach(group => {
                group.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                });
                scene.remove(group);
            });
            patternGroups = [];
        }

        function buildPatterns() {
            // For single-axis layouts, only render patterns in the appropriate orientation
            if (currentLayout === 'vertical' || currentLayout === 'horizontal') {
                const mode = (currentLayout === 'vertical') ? 'vertical' : 'horizontal';
                const patterns = parsePatterns(config.csv, mode);

                patterns.forEach((p, i) => createPatternGroup(p, i, 0));
                return;
            }

            // For other layouts, render both vertical and horizontal pattern demonstrations
            const verticalPatterns = parsePatterns(config.csv, 'vertical');
            const horizontalPatterns = parsePatterns(config.csv, 'horizontal');

            verticalPatterns.forEach((p, i) => createPatternGroup(p, i, 0));

            const verticalRows = Math.ceil(verticalPatterns.length / config.patternsPerRow);
            horizontalPatterns.forEach((p, i) => createPatternGroup(p, i, verticalRows + 1));
        }


        /**
         * ============================================================================
         * LAYOUT SWITCHING
         * ============================================================================
         */

        function switchLayout(layoutName) {
            if (!layouts[layoutName]) {
                console.warn(`Unknown layout: ${layoutName}`);
                return;
            }

            currentLayout = layoutName;
            detectedRows = null;  // Reset detected rows for new layout
            // Reset current URLs - will be restored by restoreLayoutUrls()
            currentVerticalUrl = null;
            currentHorizontalUrl = null;
            localStorage.setItem('selectedLayout', layoutName);

            // Update description
            DOM.layoutDescription.textContent = layouts[layoutName].description;

            // Show/hide second texture UI based on singleTexture mode
            const isSingleTexture = layouts[layoutName].singleTexture;
            DOM.atlasPreviewHorizontal.style.display = isSingleTexture ? 'none' : 'block';
            DOM.labelHorizontal.style.display = isSingleTexture ? 'none' : 'block';
            DOM.uploadHorizontal.style.display = isSingleTexture ? 'none' : 'flex';

            // Update label for single texture mode
            DOM.labelVertical.textContent = isSingleTexture ? 'Texture' : 'Vertical (sides)';

            // Clear existing scene
            clearPatterns();
            clearMaterialCache();

            // Reload textures and rebuild
            loadTextures(() => {
                buildPatterns();
            });
        }


        /**
         * ============================================================================
         * RENDER LOOP
         * ============================================================================
         */

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        /**
         * ============================================================================
         * AUTO-RELOAD
         * ============================================================================
         */

        let reloadIntervalId = null;
        let lastModified = { horizontal: null, vertical: null };

        // Use DOM cache aliases for readability
        const autoReloadCheckbox = DOM.autoReload;
        const reloadStatus = DOM.reloadStatus;

        async function checkForChanges() {
            try {
                const timestamp = Date.now();
                
                // Use currently loaded URLs (from user input) or fall back to default
                const verticalUrl = currentVerticalUrl || config.verticalTexture;
                const horizontalUrl = currentHorizontalUrl || config.horizontalTexture;

                const [respH, respV] = await Promise.all([
                    fetch(`${horizontalUrl}?t=${timestamp}`, { cache: 'no-store' }),
                    fetch(`${verticalUrl}?t=${timestamp}`, { cache: 'no-store' })
                ]);

                const modH = respH.headers.get('Last-Modified') || respH.headers.get('ETag') || timestamp;
                const modV = respV.headers.get('Last-Modified') || respV.headers.get('ETag') || timestamp;

                let hasReloaded = false;

                if (lastModified.horizontal && lastModified.horizontal !== modH) {
                    await reloadTexture('horizontal');
                    hasReloaded = true;
                }
                if (lastModified.vertical && lastModified.vertical !== modV) {
                    await reloadTexture('vertical');
                    hasReloaded = true;
                }

                lastModified.horizontal = modH;
                lastModified.vertical = modV;

                if (hasReloaded) {
                    reloadStatus.textContent = `Reloaded at ${new Date().toLocaleTimeString()}`;
                }
            } catch (error) {
                console.warn('Auto-reload check failed:', error);
            }
        }

        function reloadTexture(type) {
            return new Promise((resolve) => {
                const isHorizontal = type === 'horizontal';
                // Use currently loaded URLs (from user input) or fall back to default
                const baseUrl = isHorizontal 
                    ? (currentHorizontalUrl || config.horizontalTexture)
                    : (currentVerticalUrl || config.verticalTexture);
                const url = `${baseUrl}?t=${Date.now()}`;
                const previewId = isHorizontal ? 'atlasPreviewHorizontal' : 'atlasPreviewVertical';

                loader.load(url, (tex) => {
                    const newTexture = createUpscaledTexture(tex, previewId);

                    if (isHorizontal) {
                        horizontalTexture = newTexture;
                    } else {
                        verticalTexture = newTexture;
                    }

                    // Use refactored utility function
                    updateCachedMaterials(type);

                    resolve();
                });
            });
        }

        function toggleAutoReload(enabled) {
            localStorage.setItem('autoReload', enabled);

            if (enabled) {
                reloadStatus.textContent = 'Watching...';
                reloadStatus.classList.add('active');
                lastModified = { horizontal: null, vertical: null };
                checkForChanges();
                reloadIntervalId = setInterval(checkForChanges, config.reloadInterval);
            } else {
                reloadStatus.textContent = '';
                reloadStatus.classList.remove('active');
                if (reloadIntervalId) {
                    clearInterval(reloadIntervalId);
                    reloadIntervalId = null;
                }
            }
        }

        autoReloadCheckbox.addEventListener('change', () => {
            toggleAutoReload(autoReloadCheckbox.checked);
        });


        /**
         * ============================================================================
         * TEXTURE FILE UPLOAD
         * Allows loading custom textures from user's computer
         * ============================================================================
         */

        // Use DOM cache aliases for readability
        const fileVerticalInput = DOM.fileVertical;
        const fileHorizontalInput = DOM.fileHorizontal;
        const fileNameVertical = DOM.fileNameVertical;
        const fileNameHorizontal = DOM.fileNameHorizontal;

        /**
         * Core function to apply a loaded texture image to the scene.
         * Handles texture assignment, row detection, and material updates.
         * @param {HTMLImageElement} image - The loaded image
         * @param {string} type - 'horizontal' or 'vertical'
         * @returns {boolean} true if scene was rebuilt due to row change
         */
        function applyLoadedTexture(image, type) {
            const isHorizontal = type === 'horizontal';
            const previewId = isHorizontal ? 'atlasPreviewHorizontal' : 'atlasPreviewVertical';
            const isSingleTexture = layouts[currentLayout].singleTexture;

            // Store old rows to detect if we need a full rebuild
            const oldRows = config.rows;

            // Create texture from image
            const fakeTexture = { image };
            const newTexture = createUpscaledTexture(fakeTexture, previewId);

            // Assign texture(s)
            if (isSingleTexture) {
                horizontalTexture = newTexture;
                verticalTexture = newTexture;
            } else if (isHorizontal) {
                horizontalTexture = newTexture;
            } else {
                verticalTexture = newTexture;
            }

            // If rows changed (autoDetectRows), we need to rebuild everything
            if (layouts[currentLayout].autoDetectRows && config.rows !== oldRows) {
                console.log(`Rows changed from ${oldRows} to ${config.rows}, rebuilding scene...`);
                clearPatterns();
                clearMaterialCache();
                buildPatterns();
                return true;
            }

            // Update all cached materials using the utility function
            updateCachedMaterials(isSingleTexture ? 'both' : type);
            return false;
        }

        /**
         * Loads a texture from a File object and updates the scene.
         */
        function loadTextureFromFile(file, type) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        applyLoadedTexture(img, type);
                        resolve();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        fileVerticalInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            fileNameVertical.textContent = file.name;
            DOM.uploadVerticalBtn.classList.add('loaded');

            await loadTextureFromFile(file, 'vertical');
        });

        fileHorizontalInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            fileNameHorizontal.textContent = file.name;
            DOM.uploadHorizontalBtn.classList.add('loaded');

            await loadTextureFromFile(file, 'horizontal');
        });


        /**
         * ============================================================================
         * URL TEXTURE LOADING
         * Allows loading textures from a direct URL (e.g., local server)
         * ============================================================================
         */

        // Use DOM cache aliases for readability
        const urlVerticalInput = DOM.urlVertical;
        const urlHorizontalInput = DOM.urlHorizontal;
        const loadUrlVerticalBtn = DOM.loadUrlVerticalBtn;
        const loadUrlHorizontalBtn = DOM.loadUrlHorizontalBtn;

        // Default URL prefix for texture loading (fallback when just filename is provided)
        const DEFAULT_TEXTURE_URL_PREFIX = 'http://localhost:8080/textures/';

        /**
         * Resolves a texture URL - adds default prefix if it's just a filename
         */
        function resolveTextureUrl(input) {
            // If it's already a full URL, use as-is
            if (input.startsWith('http://') || input.startsWith('https://') || input.startsWith('/')) {
                return input;
            }
            // If it already starts with 'textures/', it's a relative path - use as-is
            if (input.startsWith('textures/')) {
                return input;
            }
            // Otherwise, prepend the default prefix
            return DEFAULT_TEXTURE_URL_PREFIX + input;
        }

        /**
         * Loads a texture from a URL and updates the scene.
         * Automatically adds default prefix if just a filename is provided.
         */
        function loadTextureFromUrl(input, type) {
            const url = resolveTextureUrl(input);

            return new Promise((resolve, reject) => {
                // Add timestamp to bypass cache
                const urlWithCache = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();

                loader.load(urlWithCache, (tex) => {
                    // Use the shared applyLoadedTexture function
                    applyLoadedTexture(tex.image, type);
                    resolve();
                }, undefined, (err) => {
                    console.error(`Failed to load texture from URL: ${url}`, err);
                    reject(err);
                });
            });
        }

        // Load vertical texture from URL
        loadUrlVerticalBtn.addEventListener('click', async () => {
            const input = urlVerticalInput.value.trim();
            if (!input) return;

            try {
                await loadTextureFromUrl(input, 'vertical');
                // Update current URL for auto-reload
                currentVerticalUrl = resolveTextureUrl(input);
                fileNameVertical.textContent = 'URL loaded';
                DOM.uploadVerticalBtn.classList.add('loaded');
                // Save input to localStorage per layout
                localStorage.setItem(`urlVertical_${currentLayout}`, input);
                // Save as custom URL for Current button
                localStorage.setItem(`customUrlVertical_${currentLayout}`, input);
                // Activate Current button and save preset
                updatePresetButtons('current');
                localStorage.setItem('texturePreset', 'current');
            } catch (err) {
                fileNameVertical.textContent = 'Error!';
            }
        });

        // Load horizontal texture from URL
        loadUrlHorizontalBtn.addEventListener('click', async () => {
            const input = urlHorizontalInput.value.trim();
            if (!input) return;

            try {
                await loadTextureFromUrl(input, 'horizontal');
                // Update current URL for auto-reload
                currentHorizontalUrl = resolveTextureUrl(input);
                fileNameHorizontal.textContent = 'URL loaded';
                DOM.uploadHorizontalBtn.classList.add('loaded');
                // Save input to localStorage per layout
                localStorage.setItem(`urlHorizontal_${currentLayout}`, input);
                // Save as custom URL for Current button
                localStorage.setItem(`customUrlHorizontal_${currentLayout}`, input);
                // Activate Current button and save preset
                updatePresetButtons('current');
                localStorage.setItem('texturePreset', 'current');
            } catch (err) {
                fileNameHorizontal.textContent = 'Error!';
            }
        });

        // Allow Enter key to trigger URL load
        urlVerticalInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') loadUrlVerticalBtn.click();
        });

        urlHorizontalInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') loadUrlHorizontalBtn.click();
        });


        /**
         * ============================================================================
         * INITIALIZATION
         * ============================================================================
         */

        // Use DOM cache alias for readability
        const layoutSelect = DOM.layoutSelect;

        // Restore saved layout
        const savedLayout = localStorage.getItem('selectedLayout');
        if (savedLayout && layouts[savedLayout]) {
            currentLayout = savedLayout;
            layoutSelect.value = savedLayout;
            DOM.layoutDescription.textContent = layouts[savedLayout].description;
        }

        // Update UI visibility based on singleTexture mode
        function updateSingleTextureUI() {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            DOM.atlasPreviewHorizontal.style.display = isSingleTexture ? 'none' : 'block';
            DOM.labelHorizontal.style.display = isSingleTexture ? 'none' : 'block';
            DOM.uploadHorizontal.style.display = isSingleTexture ? 'none' : 'flex';
            DOM.labelVertical.textContent = isSingleTexture ? 'Texture' : 'Vertical (sides)';
        }
        updateSingleTextureUI();

        // Restore saved URLs for current layout
        function restoreLayoutUrls() {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            const savedUrlVertical = localStorage.getItem(`urlVertical_${currentLayout}`);
            const savedUrlHorizontal = localStorage.getItem(`urlHorizontal_${currentLayout}`);

            // Use saved URL or default texture from layout definition
            const defaultVertical = layouts[currentLayout].verticalTexture;
            const defaultHorizontal = layouts[currentLayout].horizontalTexture;

            urlVerticalInput.value = savedUrlVertical || defaultVertical;
            urlHorizontalInput.value = isSingleTexture ? '' : (savedUrlHorizontal || defaultHorizontal);

            // Update current URLs for auto-reload
            currentVerticalUrl = savedUrlVertical ? resolveTextureUrl(savedUrlVertical) : null;
            currentHorizontalUrl = (!isSingleTexture && savedUrlHorizontal) ? resolveTextureUrl(savedUrlHorizontal) : null;

            // Update UI state
            fileNameVertical.textContent = savedUrlVertical ? 'URL saved' : 'default';
            fileNameHorizontal.textContent = isSingleTexture ? '' : (savedUrlHorizontal ? 'URL saved' : 'default');

            DOM.uploadVerticalBtn.classList.toggle('loaded', !!savedUrlVertical);
            DOM.uploadHorizontalBtn.classList.toggle('loaded', !isSingleTexture && !!savedUrlHorizontal);

            // Update vertical button label for single texture mode
            DOM.uploadVerticalBtn.textContent = isSingleTexture ? 'Load Texture' : 'Load Vertical';
            
            // Update Current button visibility based on whether custom URLs exist for this layout
            const hasCustomUrl = localStorage.getItem(`customUrlVertical_${currentLayout}`);
            DOM.presetCurrent.style.display = hasCustomUrl ? 'inline-block' : 'none';
        }
        restoreLayoutUrls();

        // Layout change handler
        layoutSelect.addEventListener('change', (e) => {
            switchLayout(e.target.value);
            restoreLayoutUrls();
        });

        // Restore auto-reload state
        if (localStorage.getItem('autoReload') === 'true') {
            autoReloadCheckbox.checked = true;
            toggleAutoReload(true);
        }


        /**
         * ============================================================================
         * TEXTURE PRESETS
         * Quick switch between numbered and example textures
         * ============================================================================
         */

        // Use DOM cache aliases for readability
        const presetNumberedBtn = DOM.presetNumbered;
        const presetExampleBtn = DOM.presetExample;
        const presetCurrentBtn = DOM.presetCurrent;

        // Texture presets for each layout (filenames only, prefix added by resolveTextureUrl)
        const texturePresets = {
            numbered: {
                full: { vertical: 'full_vertical.png', horizontal: 'full_horizontal.png' },
                simple: { vertical: 'simple_vertical.png', horizontal: 'simple_horizontal.png' },
                compact: { vertical: 'compact_vertical.png', horizontal: 'compact_horizontal.png' },
                horizontal: { vertical: 'horizontal.png', horizontal: 'horizontal.png' },
                vertical: { vertical: 'vertical.png', horizontal: 'vertical.png' }
            },
            example: {
                full: { vertical: 'full_vertical_ex.png', horizontal: 'full_horizontal_ex.png' },
                simple: { vertical: 'simple_vertical_ex.png', horizontal: 'simple_horizontal_ex.png' },
                compact: { vertical: 'compact_vertical_ex.png', horizontal: 'compact_horizontal_ex.png' },
                horizontal: { vertical: 'horizontal_ex.png', horizontal: 'horizontal_ex.png' },
                vertical: { vertical: 'vertical_ex.png', horizontal: 'vertical_ex.png' }
            }
        };

        /**
         * Loads a texture set (vertical + optional horizontal) and rebuilds the scene.
         * @param {string} verticalUrl - URL for vertical texture
         * @param {string|null} horizontalUrl - URL for horizontal texture (null for single texture layouts)
         * @param {Function} onComplete - Callback when loading is complete
         */
        function loadTextureSet(verticalUrl, horizontalUrl, onComplete) {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            const timestamp = '?t=' + Date.now();
            
            clearPatterns();
            clearMaterialCache();
            
            let loaded = 0;
            const targetLoads = isSingleTexture ? 1 : 2;
            
            const onLoad = () => {
                loaded++;
                if (loaded === targetLoads) {
                    buildPatterns();
                    if (onComplete) onComplete();
                }
            };
            
            const onError = (err) => {
                console.error('Failed to load texture:', err);
                onLoad(); // Continue anyway to avoid getting stuck
            };
            
            if (isSingleTexture) {
                loader.load(verticalUrl + timestamp, (tex) => {
                    horizontalTexture = createUpscaledTexture(tex, 'atlasPreviewVertical');
                    verticalTexture = horizontalTexture;
                    onLoad();
                }, undefined, onError);
            } else {
                loader.load(horizontalUrl + timestamp, (tex) => {
                    horizontalTexture = createUpscaledTexture(tex, 'atlasPreviewHorizontal');
                    onLoad();
                }, undefined, onError);
                loader.load(verticalUrl + timestamp, (tex) => {
                    verticalTexture = createUpscaledTexture(tex, 'atlasPreviewVertical');
                    onLoad();
                }, undefined, onError);
            }
        }

        function applyTexturePreset(presetType) {
            const isSingleTexture = layouts[currentLayout].singleTexture;
            let verticalUrl, horizontalUrl, uiLabel;
            
            // Handle 'current' preset - load from custom saved URLs
            if (presetType === 'current') {
                const customVertical = localStorage.getItem(`customUrlVertical_${currentLayout}`);
                const customHorizontal = localStorage.getItem(`customUrlHorizontal_${currentLayout}`);
                
                if (!customVertical) {
                    console.warn('No custom texture saved for this layout');
                    return;
                }
                
                verticalUrl = resolveTextureUrl(customVertical);
                horizontalUrl = customHorizontal 
                    ? resolveTextureUrl(customHorizontal) 
                    : layouts[currentLayout].horizontalTexture;
                
                // Update URL inputs
                urlVerticalInput.value = customVertical;
                if (!isSingleTexture) {
                    urlHorizontalInput.value = customHorizontal || layouts[currentLayout].horizontalTexture;
                }
                
                uiLabel = 'custom';
                fileNameHorizontal.textContent = isSingleTexture ? '' : (customHorizontal ? 'custom' : 'default');
            } else {
                // Handle numbered/example presets
                const preset = texturePresets[presetType]?.[currentLayout];
                if (!preset) return;
                
                verticalUrl = resolveTextureUrl(preset.vertical);
                horizontalUrl = resolveTextureUrl(preset.horizontal);
                
                // Update URL inputs
                urlVerticalInput.value = preset.vertical;
                if (!isSingleTexture) {
                    urlHorizontalInput.value = preset.horizontal;
                }
                
                uiLabel = presetType;
                fileNameHorizontal.textContent = isSingleTexture ? '' : presetType;
            }
            
            // Update current URLs for auto-reload
            currentVerticalUrl = verticalUrl;
            currentHorizontalUrl = isSingleTexture ? null : horizontalUrl;
            
            // Update button states and save preset
            updatePresetButtons(presetType);
            localStorage.setItem('texturePreset', presetType);
            
            // Load textures and update UI
            loadTextureSet(verticalUrl, horizontalUrl);
            fileNameVertical.textContent = uiLabel;
        }

        // Helper function to update preset button states
        function updatePresetButtons(activePreset) {
            presetCurrentBtn.classList.toggle('active', activePreset === 'current');
            presetNumberedBtn.classList.toggle('active', activePreset === 'numbered');
            presetExampleBtn.classList.toggle('active', activePreset === 'example');
            
            // Show/hide Current button based on whether custom URLs exist
            const hasCustomUrl = localStorage.getItem(`customUrlVertical_${currentLayout}`);
            presetCurrentBtn.style.display = hasCustomUrl ? 'inline-block' : 'none';
        }

        presetCurrentBtn.addEventListener('click', () => applyTexturePreset('current'));
        presetNumberedBtn.addEventListener('click', () => applyTexturePreset('numbered'));
        presetExampleBtn.addEventListener('click', () => applyTexturePreset('example'));

        // Restore preset state
        const savedPreset = localStorage.getItem('texturePreset');
        if (savedPreset) {
            updatePresetButtons(savedPreset);
        } else {
            // Hide Current button if no custom URLs exist
            const hasCustomUrl = localStorage.getItem(`customUrlVertical_${currentLayout}`);
            presetCurrentBtn.style.display = hasCustomUrl ? 'inline-block' : 'none';
        }


        /**
         * ============================================================================
         * UPLOAD BUTTON HANDLERS (moved from inline onclick)
         * ============================================================================
         */
        
        DOM.uploadVerticalBtn.addEventListener('click', () => {
            fileVerticalInput.click();
        });
        
        DOM.uploadHorizontalBtn.addEventListener('click', () => {
            fileHorizontalInput.click();
        });


        // Initial load
        loadTextures(() => {
            buildPatterns();
            // Ensure positions are correct after first load
            setTimeout(updatePreviewPositions, 100);
        });
    </script>
</body>

</html>